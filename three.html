<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hornet ‚Äî Bone Control (Three.js, Legacy)</title>
  <style>
    html, body { margin:0; height:100%; background:#181a1b; overflow:hidden; }
    #hud { position:fixed; left:12px; bottom:12px; color:#fff; background:rgba(0,0,0,.6);
           border:1px solid rgba(255,255,255,.25); border-radius:999px; padding:8px 12px;
           font:14px system-ui,sans-serif; pointer-events:none; }
    #status { position:fixed; right:12px; bottom:12px; color:#fff; background:rgba(0,0,0,.6);
              border:1px solid rgba(255,255,255,.25); border-radius:999px; padding:8px 12px;
              font:14px system-ui,sans-serif; pointer-events:none; }
    canvas { display:block; }
  </style>

  <!-- THREE.js and helper scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
  <div id="hud">üñ±Ô∏è Click = Play clip ‚Ä¢ üñ±Ô∏è Double-Click = Head tilt ‚Ä¢ üñ±Ô∏è Right-Click = Sword back</div>
  <div id="status">Loading‚Ä¶</div>

  <script>
    // Global THREE.js variables and objects
    const status = document.getElementById('status');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x181a1b);

    const cam = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);
    cam.position.set(1.2, 1.0, 2.0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(cam, renderer.domElement);
    controls.enableDamping = true;

    // Lighting and ground
    scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(3, 5, 2);
    scene.add(dir);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 10),
      new THREE.MeshStandardMaterial({ color: 0x0f1112, roughness: 1 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Handle window resize
    addEventListener('resize', () => {
      cam.aspect = innerWidth / innerHeight;
      cam.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Tween helper for smooth animations
    function tween(ms, update, done) {
      const t0 = performance.now();
      function frame(t) {
        const u = Math.min(1, (t - t0) / ms);
        update(u);
        if (u < 1) requestAnimationFrame(frame);
        else done && done();
      }
      requestAnimationFrame(frame);
    }

    // Load the GLB model
    const loader = new THREE.GLTFLoader();
    let root = null, mixer = null, clips = [];
    let headNode = null, swordNode = null;

    const HEAD_CANDIDATES = ['Head', 'head', 'mixamorig:Head', 'DEF-Head', 'Bip001_Head'];
    const SWORD_CANDIDATES = ['NEEDLE', 'Needle', 'needle', 'Sword', 'sword', 'Weapon', 'weapon'];

    function findNodeByCandidates(root, names) {
      let skinned = null;
      root.traverse(o => { if (o.isSkinnedMesh && !skinned) skinned = o; });
      if (skinned && skinned.skeleton) {
        for (const n of names) {
          const b = skinned.skeleton.getBoneByName(n);
          if (b) return b;
        }
      }
      for (const n of names) {
        const o = root.getObjectByName(n);
        if (o) return o;
      }
      return null;
    }

    // Load the model
    loader.load(
      'hornet.glb',
      (gltf) => {
        status.textContent = 'Framing‚Ä¶';
        root = gltf.scene;
        root.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });
        scene.add(root);

        // Center model on the ground
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);
        root.position.sub(center);
        root.position.y = size.y * 0.5;

        clips = gltf.animations || [];
        if (clips.length) {
          mixer = new THREE.AnimationMixer(root);
          console.log('Animations:', clips.map(c => c.name));
        } else {
          console.log('No clips in file.');
        }

        // Locate head and sword nodes
        headNode = findNodeByCandidates(root, HEAD_CANDIDATES);
        swordNode = findNodeByCandidates(root, SWORD_CANDIDATES);

        console.log('Head node:', headNode && headNode.name || '(not found)');
        console.log('Sword/needle node:', swordNode && swordNode.name || '(not found)');

        // Log all node names for debugging
        const names = [];
        root.traverse(n => names.push(n.name));
        console.log('All node names:', names);

        status.textContent = 'Ready';
        setTimeout(() => status.remove(), 1200);
      },
      (xhr) => {
        const p = xhr.total ? Math.round(xhr.loaded / xhr.total * 100) : 0;
        status.textContent = `Loading‚Ä¶ ${p}%`;
      },
      (err) => {
        console.error('GLB load error:', err);
        status.textContent = 'Load error (open console)';
      }
    );

    // Render loop
    const clock = new THREE.Clock();
    function tick() {
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);
      controls.update();
      renderer.render(scene, cam);
      requestAnimationFrame(tick);
    }
    tick();

    // --- Interactions ---
    renderer.domElement.addEventListener('click', () => {
      if (!mixer || !clips.length) return;
      let clip = clips.find(c => /HORNET/i.test(c.name)) || clips[0];
      const action = mixer.clipAction(clip);
      action.reset().play();
      setTimeout(() => action.stop(), 2000);
    });

    renderer.domElement.addEventListener('dblclick', () => {
      if (!headNode) { console.warn('Head bone not found ‚Äî check console names.'); return; }
      const baseX = headNode.rotation.x;
      tween(700, (u) => {
        const ease = 1 - Math.pow(1 - u, 3);
        headNode.rotation.x = baseX - Math.sin(ease * Math.PI) * 0.45; // ~26¬∞
      }, () => headNode.rotation.x = baseX);
    });

    renderer.domElement.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (!swordNode) { console.warn('Sword/needle node not found ‚Äî check console names.'); return; }
      const baseX = swordNode.rotation.x;
      tween(600, (u) => {
        const upDown = u < 0.5 ? (u * 2) : (1 - (u - 0.5) * 2); // up then down
        swordNode.rotation.x = baseX - upDown * 0.5;   // ~28.6¬∞
      }, () => swordNode.rotation.x = baseX);
    });
  </script>
</body>
</html>
